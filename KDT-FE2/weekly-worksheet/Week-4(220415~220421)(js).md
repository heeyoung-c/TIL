# JS 데이터(자료형, Date Type)

## 원시형(Primitive type)

1. String
1. Number
1. Boolean
1. null
1. undefined
1. Symbol
1. BigInt
<br>
<br>
## 참조형(Reference type)

1. Array
1. Object
1. Function
<br>
<br>

## String

따옴표로 묶여 있어야 한다

```js
"Hee"
'Hee'
`Hee` // 보간!
```
모두 문자 데이터로 표현 되지만, 

벡틱기호는 그 쓰임이 조금 다르다

보간을 통해서 데이터를 사용할 수 있다

```js
const abc = 'ABC'
console.log(`Hello ${abc}`) //보간을 통해 변수 abc의 값을 사용
```
<br>
<br>

## Number
<br>
<br>

### 부동 소수점 오류

컴퓨터가 숫자를 표시하는 방법에 한계가 있기 때문에, 

십진수를 이진수로 변환하는 과정에서 발생하는 오류

```js
const a = 0.1
const b = 0.2
console.log(a + b) 
// 0.30000000000000004

const a = 0.1
const b = 0.2
console.log(
  (a + b).toFixed(1)
// 0.3
// 하지만 이런 경우에 문자가 출력된다

const a = 0.1
const b = 0.2
console.log(
  parseFloat((a + b).toFixed(1))
)
//정상적으로 숫자가 출력된다
```

```js
const a = 1
const b = undefined
console.log(a * b)
// NaN (Not-A-Number)
```
NaN (Not-A-Number) - 숫자 데이터 / 숫자로 표시가 불가!
<br>
<br>

## Boolean

```js
true
false
```
대표적으로 조건문에서 사용된다

```js
if (true) {
  console.log('참!')
}
// result ... 참!
```
<br>
<br>

## null

'존재하지 않는', '비어 있는', '알 수 없는' 값을 명시적으로 나타냄

```js
const user {
  name: 'heeyoung',
  age: null,
}
```
<br>
<br>

## undefined

'값이 할당되지 않은 상태'를 암시적으로 나타냄

```js
let a
console.log(a)
// result ... undefined
// 변수 a의 값이 할당되어있지 않기 때문
```

undefined는 암시적인 것이고, null은 명시적인 것이다

undefined는 그릇은 존재하나, 값이 없다

null은 직접 넣은 값이다
<br>
<br>

## Symbol

유일한 식별자(ID) 데이터 이름을 만들 때 사용

```js
const s = Symbol('Hello world') // 설명

const user = {
  name: 'HeeYoung',
  [s]: 81
}

console.log(user.name)
// Heeyoung

console.log(user[s])
// 81
```
81이라는 값에 접근 하기 위해선 유일한 식별자, 즉 일종의 Key가 필요하다
<br>
<br>

## BigInt

큰(Big) 정수(Integer)

```js
console.log(123n)
// 해당 값은 BigInt이다
```
2^53-1 의 값이 JS에서 표현할 수 있는 가장 큰 숫자인데,

이 수보다 큰 값을 표현할 때 BigInt를 사용한다
<br>
<br>

## Array

```js
const arr = [1, '2', 3, {}, () => {}]

console.log(a[0])
```
배열안에 값은 배열의 item 혹은 element 라고 불린다

index 번호는 0부터 시작한다

index 번호를 사용하여 배열의 item을 조회하는 행위를 indexing이라 한다

```js
const a = ['Apple', 'Banana', 'Cherry']
// 리터럴 방식, 기호를 통해 데이터를 생성

const b = new Array('Apple', 'Banana', 'Cherry')
// 클래스 방식
```
<br>
<br>

## Object

```js
const obj = {
  a: 'Apple',
  b: 'Banana',
  c: 'Cherry',
  b: 'Big'
}
// Key: Value 형태
```
Key라는 것은 고유하다

Key가 같은 값이 할당되어 있으면, 나중에 표현된 값만 선언된다

```js
console.log(obj.a) //점(Dot) 표기법
console.log(obj['a']) //괄호(Bracket) 표기법
```
괄호표기법을 사용할 경우, Key의 값에 특수문자가 표현되어 있을 경우, 값을 가져올 수 있다

```js
const obj = {
  'ASDF@#@$@SDA121-13' : 'Apple',
  b: 'Banana',
  _c: 'Cherry'
}

console.log(obj['ASDF@#@$@SDA121-13']) O
console.log(obj.'ASDF@#@$@SDA121-13') X
// 이런 경우 괄호 표기법만 사용 가능
```
_(under-bar) 같은 경우엔 해당 값을 숨기는 용도로 사용한다

실제로 숨겨지지는 않지만, 그러한 의도를 가지고 사용한다
<br>
<br>

## Function

```js
 function () {
   // 명령1
   // 명령2
   // 명령3
   // 명령4
 }
// 함수는 묶음처리만 해서는 쓸 수 없기 때문에, 함수에 이름을 부여해줄 수 있다.

 function Hee() {
   // 명령1
   // 명령2
   // 명령3
   // 명령4
 }

```
핵심은, 함수도 하나의 데이터라는 것이다
<br>
<br>


# 형(Type)변환

```js
const a = 123
const b = 123

console.log(a == b)
// 동등 연산자

const c = 123
const d ='123'

console.log(c == b)
// result ... true
```
형변환

자동으로 값이 변환되어 true 값으로 나옴

동등 연산자는 쓰지 말 것!

```js
const a = 1
const b = true

console.log(a == b)
// true
```
이러한 문제 때문에

일치 연산자를 사용한다

`===` 완전히 같은 지 확인 하는 것

일치 연산자는 메모리 주소를 비교한다

원시형은 생긴 게 같으면 주소가 같다

참조형은 생긴 게 같아도 주소가 다를 수 있다
<br>
<br>

# Truthy & Falsy
참과 같은 값 / 거짓과 같은
값
<br>
<br>

## Falsy
```js
if (false)
if (null)
if (undefined)
if (0)
if (-0)
if (NaN)
if (0n)
if ('')

if (' ') // 공백 문자는 Truthy이다
```
부정적인 느낌은 Falsy

주의할 것은, 공백 문자가 들어 있는 경우, Truthy이다
<br>
<br>

# 자료형 확인

데이터는 눈으로 보이는 게 아니기 때문에, 데이터의 타입을 명확하게 해줄 필요가 있다

1. `typeof 데이터`
```js
console.log(typeof '123') //string
console.log(typeof 123) // number
console.log(typeof true) // boolean
console.log(typeof null) // object ??
console.log(typeof undefined) // undefined
console.log(typeof Symbol('aabbcc')) //symbol
console.log(typeof 123n) //bigint
console.log(typeof []) // object ??
console.log(typeof {}) // object
console.log(typeof function () {}) // function

```
데이터의 타입은 항상 확인 할 수 있어야 한다

null 과 array는 typeof로 알아 낼 수 없다!
<br>
<br>

## `Array` 타입을 알아내는 방법

1. `데이터.constructor`
```js
console.log([].constructor === Array)
console.log(Array.isArray(''))
```
배열을 알아내는 두가지 방법

하지만 null은 파악 할 수 없다
<br>
<br>

## `null` 을 포함한 모든 데이터의 타입을 알아내는 방법
1. `Object.prototype.toString.call(데이터)`
이 방식을 사용하면 모든 데이터의 타입을 확인 할 수 있다

```js
function checkType(data) {
  return Object.prototype.toString.call(data)
}
console.log(checkType([]))
// [object Array]


function checkType(data) {
  return Object.prototype.toString.call(data).slice(8, -1)
}
console.log(checkType(undefined))
// undefined
```
`data` 부분은 인수(argument)가 들어가는데, 이런 경우를 매개변수라 한다

`data` 부분의 이름은 원하는 이름을 사용할 수 있다
<br>
<br>

# 변수

```js
const a = 123
// a 라는 변수에 123이라는 숫자 데이터를 담는다
```
만약 메모리의 주소를 '서울' 이라고 해보자

a라는 변수는 '서울' 메모리 주소를 바라보고 있다

`console.log(a)`를 하는 경우, '서울' 메모리에서 숫자 데이터 `123`을 가져오는 것이다
<br>
<br>

## 변수 선언의 차이점

- 유효범위(Scope)
- 재할당 가능 여부
- 중복 선언 가능 여부
- 호이스팅(Hoisting)
- 전역(Global) 선언시 전역 객체(`window`)의 속성으로 등록


1. `const`
    - 유효범위: 블록 레벨
    - 재할당: X
    - 중복 선언: X
    - 호이스팅(Hoisting): X
    - 전역 등록: X

2. `let`
    - 유효범위: 블록 레벨
    - 재할당: O
    - 중복 선언: X
    - 호이스팅(Hoisting): X
    - 전역 등록: X

3. `var`
    - 유효범위: 함수 레벨
    - 재할당: O
    - 중복 선언: O
    - 호이스팅(Hoisting): O
    - 전역 등록: O

>호이스팅은 `var`에서만 발생하지만, 이제 `var`는 사용하지 않는 추세이다

```js
function abc() {
  if (true) {
    var a = 123
    console.log('in', a)
  }
  console.log('out', a)
}
abc ()
// in 123
// out 123

function abc() {
  if (true) {
    let a = 123
    console.log('in', a)
  }
  console.log('out', a)
}
abc ()
// in 123
// a is not defined

function abc() {
  if (true) {
    const a = 123
    console.log('in', a)
  }
  console.log('out', a)
}
abc ()
// in 123
// a is not defined
```
`var`는 함수 레벨 범위 에서는 유효하다
`let, const`는 블록 레벌 범위 에서 유효하다
<br>
<br>

## 재할당

`const`(constant)(상수)

의미적으로는 상수라고 부르지만, 정확하게는 변수이다

상수라는 개념은 값을 다시 할당할 수 없기 때문에 재할당 할 수 없다

```js
const a = 123
a = 456
// X 재할당 불가능
```
<br>
<br>

## 중복 선언
```js
const a = 123
const a = [5, 6, 7]
// XX
```
<br>
<br>

## 호이스팅

코드는 위에서 부터 아래로 평가된다

간단하게 설명하자면

선언은 밑에서 되고, 사용은 위에서 하는 경우

밑에 있는 선언부를 위로 끌어 올려서 사용하는 것

선언부가 유효범위의 최상단으로 끌어 올려지는 현상

```js
console.log(a) // X
console.log(b) // undefined

const a = 1234
var b = 5678
```
`var`의 경우 `undefined`라는 값이 할당되어 있는 것이다
<br>
<br>

## 전역 범위

```js
var heeyoung = 123

console.log(window.heeyoung)
// 123
```
사이트가 뜨고있는 창에 대한 정보는 `window`에 다 들어와있는데,

`window.heeyoung` 는 `123` 이 나온다
<br>
<br>

## 결론 ...

일단 `const`를 쓴다

재할당이 필요한 경우에만 `let`을 쓴다
<br>
<br>


# 함수

## 선언과 표현

함수는 명령들을 감싸는 역할을 한다

감싼 것을 여러군데에서 **재사용**을 하는 용도로 함수를 만든다

함수는 입구와 출구가 존재한다

입구를 통해서는 특정한 **데이터(인수)**를 받는다,

입구에서는 매개변수가 대기하고 있다가 인수를 가로챈다

매개변수를 통해 값은 return(반환)된다

```js
// 함수 선언
function abc() {

}

// 함수 표현
const abc = function () {

}
```
선언은 함수에 이름을 지정하여 선언하는 개념

표현은 이름이 없는 함수를 변수에 할당하는 개념

익명함수는 무조건 표현이다, 함수 선언이라는 것은 이름을 가지고 있어야 한다

호이스팅이라는 개념때문에 이를 이해해야한다

1. 선언: 호이스팅 O
1. 표현: 호이스팅 X