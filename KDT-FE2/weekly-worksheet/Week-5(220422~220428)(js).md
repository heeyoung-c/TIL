# `for`

```js
for (초기화; 조건; 평가식) {

}

for (시작; 종료; 변화) {

}

for (let i = 0; i < 10; i += 1) {
  console.log(i)
}

for (let i = 0; i < 10; i += 1) {
  console.log(i)
  if (i === 3) {
    break
  }
}
// 반복 도중 멈출 수 있다
```

## `for of` - 배열

반복가능객체(대표적으로 배열)

통상적으로 관리의 용이성을 위해서,  
배열 아이템의 타입은 동일하게 작성한다  

```js
const users = [
  { name: 'heeyoung', age: 85 },
  { name: 'Neo', age: 22 },
  { name: 'Lewis', age: 8 }
]
for (const u of users) {
  console.log(u)
}
// { name: 'heeyoung', age: 85 },
// { name: 'Neo', age: 22 },
// { name: 'Lewis', age: 8 }
```

## `for in` - 객체

```js
const hee = {
  name: 'heeyoung',
  age: 99,
  isValid: true
}
for (const key in heropy) {
  console.log(key)
}
// name
// age
// isValid


for (const key in heropy) {
  console.log(hee[key])
}
// heeyoung
// 99
// true
```

# `while` & `do while`

조건이 **Truthy** 라면 무한반복

```js
// while
while (조건) {

}

let i = 0 // 시작
while (i < 3) { // 종료
  console.log(i)
  i += 1 // 변화
}
// 0
// 1
// 2

// do while
let j = 0 // 시작
do {
  console.log(j)
  j += 1 // 변화
} while (j < 3) // 종료
// 0
// 1
// 2
```
`while`은 조건이 `falsy`라면 한 번도 동작하지 않는다  
`do while`은 조건이 `falsy`여도 최소 한 번은 동작한다

# 표준 내장 객체(메소드)

## `String.prototype`

`String.prototype.` 형태의 메소드의 경우, 문자 뒤에 바로 붙일 수 있다  
`String.raw()` 같은 경우는, 스태틱 메소드이므로, 문자 뒤에 바로 쓸 수는 없다

### `.length()`
```js
const str = 'Hello world'
console.log(str.length)
// 11
```

### `.includes()`
```js
const str = 'I am a fox'
console.log(str.includes('fox'))
// true
```

### `.indexOf()`
```js
const str = 'I am a fox'
console.log(str.indexOf('fox'))
// 7
// 중복으로 들어간 문자의 경우, 가장 먼저 찾은 문자열의 시작 index 번호 반환
// 일치하는 값이 없는 경우, -1 반환
```

### `.match()` (정규표현식과 같이 사용)
```js
const str = 'Hello world'
console.log(str.match(/^.*(?=\s)/gi))
// [ 'Hello' ]
```

### `.replace()`
```js
const str = 'Hello world'
console.log(str.replace('world', 'Hee'))
// Hello Hee

const str = 'Hello world'
console.log(str.replace('world', ''))
// Hello
```

### `.slice()`
```js
// slice(시작지점, 종료지점)
// 종료부분의 index 번호는 포함하지 않는다

const str = 'Hello world!'
console.log(str.replace(0, 5))
// Hello

const str = 'Hello world!'
console.log(str.replace(0, -1))
// Hello world
```

### `.split()`
```js
const str = 'Hello world'
const arr = str.split(' ')
console.log(arr)
// [ 'Hello', 'world' ]
// 반환값은 배열의 형태로 반환된다
```

### `.toUpperCase()`
```js
const str = 'Hello world'
console.log(str.toUpperCase())
// HELLO WORLD
```

### `.toLowerCase()`
```js
const str = 'Hello world'
console.log(str.toLowerCase())
// hello world
```

### `.trim()`
```js
// 앞 뒤 공백 제거

const str = '   Hi  '
console.log(str.trim())
// Hi
```

## `Number.prototype`

### `.toFixed()`
```js
const num = 3.1415912312
console.log(
  num.toFixed(2)
)
// 3.14
// 하지만 이는 String 이다

const num = 3.1415912312
console.log(
  parseFloat(num.toFixed(2))
)
// 3.14
// Number
```

## Number static method

### `isNaN()` & `Number.isNaN()`
두 개의 경우 기능적인 차이가 있다  
두 번째 형태가 권장사항이다

```js
const num = 3.14123123
console.log(
  num * undefined
)
// NaN

const num = 3.14123123
console.log(
  isNaN(num * undefined)
)
// true

const num = 3.14123123
console.log(
  Number.isNaN(num * undefined)
)
// true

// 권장사항은 Number이 붙은 형태이다
```

### `parseInt()` & `Number.parseInt()`
명시적으로 만든 것이지, **기능적인 차이가 없다**  
전역 객체의 모듈화를 위해 추가 됨

```js
const num = 3.14123123
console.log(
  parseInt(num)
)
// 3
// 반환값은 Number가 나온다
```

### `parseFloat()` & `Number.parseFloat()`
명시적으로 만든 것이지, **기능적인 차이가 없다**  
전역 객체의 모듈화를 위해 추가 됨

```js
const num = '3.14123132'
console.log(
  parseFloat(num)
)
// 3.14123123
```

### `Math()`

```js
const num = -0.45
console.log(
  Math.abs(num)
)
// 0.45
// 절댓값

const num = 0.45
console.log(
  Math.cli(num)
)
// 1
// 올림

const num = 0.45
console.log(
  Math.round(num)
)
// 0
// 반올림

const num = 0.45
console.log(
  Math.floor(num)
)
// 0
// 내림

const num = (0, 4, 2, 1, -2)
console.log(
  Math.max(num)
)
// 4
// 가장 큰 값

const num = (0, 4, 2, 1, -2)
console.log(
  Math.min(num)
)
// -2
// 가장 작은 값

console.log(
  Math.random()
)
// 랜덤한 값
// 0.xxxxx...
```

## `Array.prototype`

### `.length()`
```js
const arr = [1, 2, 3, 4] 
console.log(
  arr.length
)
// 4
```

### `.concat()`
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.concat([4, 5, 6])
)
// [1, 2, 3, 4, 4, 5, 6]
// 기존 배열에, 새로운 배열이 병합

console.log(arr)
// [1, 2, 3, 4]
// 기존 배열 손상 X
```
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.concat([4, 5, 6], [5, 6, 7])
)
// [ 1, 2, 3, 4, 4, 5, 6, 5, 6, 7]
// 기존배열.concat(새로운배열1, 새로운배열2, ...)
```

### `.every()`
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.every(item => item < 5)
)
// true

// item 개수만큼 반복실행
// 전부 다 truthy여야만, 통과했다 라고 판단
// 모든 요소가 주어진 callback 함수를 통과하는지 판단하는 메소드

const arr = [1, 2, 3, 4]
console.log(
  arr.every(item => item < 4)
)
// false
```
핵심: **모든 요소**가 통과해야 한다

### `.filter()`
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.filter(item => item < 3)
)
// [ 1, 2 ]
// 통과한 요소를 모아 새로운 배열로 반환
```
핵심: 새로운 배열로 반환된다, 원본 배열보다 개수가 **줄어들 수 있다**

### `.find()`
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.find(element => element < 3)
)
// 1
// 가장 먼저 통과한 요소를 반환한다
// 하나만 찾는 것이다

const users = [
  { name: 'Hee', age:99 },
  { name: 'Young', age:99 }
]
const foundUser = users.find(user => user.name === 'Hee')
console.log(foundUser)
// { name: 'Hee', age: 99 }
```

### `.findIndex()`
```js
const arr = [1, 2, 3, 4]
console.log(
  arr.findIndex(item => item === 3)
)
// 2
// 가장 먼저 통과한 요소의 인덱스 번호를 반환한다
// 인덱스 번호를 반환한다!!!

const test = [0, 10, 32, 2]
test.splice(
  test.findIndex(item => item === 32),
  1
)
// 지우고 싶은 요소의 index 번호를 모를 때 사용할 수 있다
```

### `.forEach()`
```js
const arr = [1, 3, 2, 4, 7]
arr.forEach(item => {
  console.log(item)
})
// 1
// 3
// 2
// 4
// 7
// forEach는 멈출 수 없다
// 무조건 배열의 개수만큼 반복한다
```

### `.includes()`
```js
const arr = [1, 3, 2, 4, 5]
console.log(
  arr.includes(7)
)
// false
```

### `.join()`
```js
const arr = [1, 3, 2, 4, 5]
console.log(
  arr.join('//')
)
// 각각의 아이템을 특정한 문자로 합친다
// 1//3//2//4//5

const arr = [1, 3, 2, 4, 5]
console.log(
  arr.join(' + ')
)
// 1 + 3 + 2 + 4 + 5

const arr = ['AR', '패션', '스포츠', '인테리어']
console.log(
  arr.join('/')
)
// AR/패션/스포츠/인테리어
```
반환값은 **문자**이다!

### `.map()`
```js
const arr = ['AR', '패션', '스포츠', '인테리어']
console.log(
  arr.map(item => ({
    name: item
  }))
)
// [ { name: 'AR' }, { name: '패션' }, { name: '스포츠' }, { name: '인테리어' } ]
```
`map`의 콜백 안에서 반환된 데이터로 **새로운 배열**을 만든다

```js
const arr = [1, 3, 2, 4]
console.log(
  arr.map(item => item * 2)
)
// [ 2, 6, 4, 8 ]
```

```js
const arr = [1, 3, 2, 4]
console.log(
  arr.map((item, index) => {
    console.log(index)
    return item * 2
  })
)
// 0
// 1
// 2
// 3
// [ 2, 6, 4, 8 ]
```

### `.pop()`
```js
const arr = [1, 3, 2, 4]
console.log(
  arr.pop()
)
// 4
// 배열의 마지막 요소를 제거하고, 해당 요소를 반환한다

console.log(arr)
// [ 1, 3, 2 ]
// 원본이 수정된다
```

### `.shift()`
```js
const arr = [1, 3, 2, 4]
console.log(
  arr.shift()
)
// 1
// 배열의 첫번째 요소를 제거하고, 해당 요소를 반환한다

console.log(arr)
// [ 3, 2, 4 ]
// 원본이 수정된다
```

### `.push()`
```js
const arr = [1, 3, 2, 4]
console.log(
  arr.push(99)
)
// 5
// 배열의 끝에 하나 이상의 요소를 추가하고, 배열의 새로운 길이를 반환

const arr = [1, 3, 2, 4]
console.log(
  arr.push(99, 7, 1273)
)
// 7
// 하나 이상을 밀어넣을 수 있다!!

console.log(arr)
// [ 1, 3, 2, 4, 99, 7, 1273 ]
// 원본이 수정된다
```

### `.unShift()`
```js
const arr = [1, 3, 2, 4]
console.log(
  arr.unshift(3)
)
// 5
// 새로운 요소를 맨 앞쪽에 추가하고, 배열의 새로운 길이를 반환

const arr = [1, 3, 2, 4]
console.log(
  arr.unshift(3, 2, 123, 2313)
)
// 8
// 하나 이상을 앞에 추가할 수 있다

console.log(arr)
// [ 3, 2, 123, 2313, 1, 3, 2, 4]
// 원본이 수정된다
```