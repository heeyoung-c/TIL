# Vue

## preview

```html
  <div id="app">
    <input v-bind:value="title" /> <!-- v-bind: 디렉티브로 data에서 정의한 데이터를 사용할 수 있다 -->
    <button v-on:click="changeTitle">Click!</button> <!-- addEventLister와 같다, changeTitle 함수는 methods에 저장된다, 해당 디렉티브를 사용한다는 것은 어떠한 메소드를 사용 한다는 것!-->
  </div>
```
```js
// 컴포넌트
const App = {
  // 반응형 데이터 || 반응성을 가진 데이터
  // data 옵션에 지정을 해놔야만 반응성을 가질 수 있다
  // 최신 프레임워크에서 가장 중요한 개념이다
  data() { // 데이터는 함수여야 한다!
    return {
      title: ''
    }
  },
  methods: { // methods에 등록하는 함수는 일반함수를 사용한다. this를 사용하기 때문
    changeTitle() {
      this.title = 'HEROPY!'  // 그냥 title이라고 쓴다면, 전역에서 title를 찾는다!
    }
  }
}
Vue.createApp(App).mount('#app')
```

### 검색 예제
```html
  <div id="app">
    <input v-model="title" v-on:keydown.enter="searchMovies(true)" /> 
     <!-- 
      v-model을 사용하여 양방향 데이터 바인딩을 만들어준다, 기본적으로는 단방향이다, 
      사용자가 입력한 결과를 바탕으로 무언가를 할 때는 양방향을 사용한다  
      -->
    <button v-on:click="searchMovies(true)">Search!</button>
    <ul>
      <li v-for="movie in movies">
        <img v-bind:src="movie.Poster" alt="" height="40">
        {{ movie.Title }}
      </li>
    </ul>
    <button v-if="movies.length" v-on:click="searchMovies()">More..</button> 
    <!-- v-if 디렉티브를 통해, movies의 length 가 1개 이상있을 경우에만 버튼이 등장한다 -->
  </div>
```
```js
const App = {
  data() { 
    return {
      title: '',
      page: 1,
      movies: [] // init
    }
  },
  methods: { 
    async searchMovies(isFirst) {
      if (isFirst) {
        this.movies = []
        this.page = 1
      }
      let res = await fetch(`https://www.omdbapi.com/?apikey=7035c60c&s=${this.title}&page=${this.page}`)
      res = await res.json()
      console.log(res)
      const { Search, totalResults } = res
      this.movies.push(...Search)
      this.page += 1
    }
  }
}
Vue.createApp(App).mount('#app')

```

## 템플릿 문법(Template Syntax)
`v-once`: 데이터를 단 한번만 화면에 렌더링하고 그 다음에는 데이터가 변경이 되더라도 화면을 갱신하지 않는 디렉티브  
`v-html`: 실제 html 구조로 출력하기 위한 디렉티브

```vue
<template>
  <h1 
    v-once
    @click="add">
    {{ msg }}
  </h1>
  <h1 v-html="msg"></h1>
</template>

<script>
export default {
  data() {
    return {
      msg: '<div style="color: red;">Hello!!</div>'
    }
  },
  methods: {
    add() {
      this.msg += '!'
    }
  }
}
</script>
```

```vue
<template>
  <h1
    :[attr]="'active'"
    @[event]="add">
    {{ msg }}
  </h1>
</template>

<script>
export default {
  data() {
    return {
      msg: 'active',
      attr: 'class',
      event: 'click'
    }
  },
  methods: {
    add() {
      this.msg += '!'
    }
  }
}
</script>

<style lang="scss" scoped>
  .active {
    color: royalblue;
    font-size: 100px;
  }
</style>

```

### 디렉티브
`v-`로 시작하는 속성
`v-for, v-model, v-bind`등등

#### 동적 전달인자
동적으로 속성의 이름을 집어 넣는다

### Data 속성

## computed 속성과 watch

### computed
기존의 만들어진 반응형 데이터로, 새롭게 계산한 새로운 데이터를 만들어서 사용하는 용도  
메소드로 사용하게 되면, 메소드를 사용하는 만큼 계산을 새로 해야하지만,  
`computed` 데이터는 캐싱이 되어있기 때문에, 1000번을 반복 출력 해도, 한 번만 계산하면 된다

해당 vue.js 옵션을 통해서 기존의 데이터를 원하는 방향으로 수정해서 사용할 수 있다

```vue
<!-- App.vue -->
<template>
  <Fruits />
</template>

<script>
import Fruits from '~/components/Fruits'

export default {
  components: {
    Fruits
  }
}
</script>

<!-- Fruits.vue -->
<template>
  <section v-if="hasFruit">
    <h1>Fruits</h1>
    <ul>
      <li
        v-for="fruit in fruits"
        :key="fruit">
        {{ fruit }}
      </li>
    </ul>
  </section>
  <section>
    <h1>Reverse Fruits</h1>
    <ul>
      <li
        v-for="fruit in reverseFruits"
        :key="fruit">
        {{ fruit }}
      </li>
    </ul>
  </section>
</template>

<script>
export default {
  data() {
    return {
      fruits: [
        'Apple', 'Banana', 'Cherry'
      ]
    }
  },
  computed: {
    hasFruit() {
      return this.fruits.length > 0
    },
    reverseFruits() {
      return this.fruits.map(fruit => {
        // 'Apple' => ['A', 'p', 'p', 'l', 'e']
        // => ['e', 'l', 'p', 'p', 'A'] => 'elppA'
        return fruit.split('').reverse().join('')
      })
    }
  }
}
</script>
```

## result
Fruits  
Apple  
Banana  
Cherry  
Reverse Fruits  
elppA  
ananaB  
yrrehC

#### `computed` 속성의 Getter & Setter
Getter & Setter
기본적으로 `computed` 속성은 Getter 문법이다

```vue
<template>
  <button @click="add">
    ADD
  </button>
  <h1>{{ reversedMessage }}</h1>
  <h1>{{ reversedMessage }}</h1>
</template>

<script>
export default {
  data() {
    return {
      // Getter, Setter
      // 값을 얻어내는 용도 + 값을 지정하는 용도
      msg: 'Hello Computed!'
    }
  },
  computed: {
    // Getter
    // 읽기 전용, 값을 얻어내는 용도로만 사용
    // reversedMessage() {
    //   return this.msg.split('').reverse().join('')
    // }
    
    // Getter ,Setter
    reversedMessage: {
      get() {
        return this.msg.split('').reverse().join('')
      },
      set(newValue) {
        console.log(newValue)
        // !detupmoC olleH!?
      }
    }
  },
  methods: {
    add() {
      this.reversedMessage += '!?'
    }
  }
}
</script>
```

### watch
반응형 데이터가 바뀌었을 때, 감시하는 역할

즉 우리가 알고있는 특정한 데이터들의 변경사항을 감시하는 역할   
특정한 데이터가 변경되는 것을 감시해서, 추가적인 로직을 만들어줄 때 사용하는 옵션  

```vue
<template>
  <h1 @click="changeMessage">
    {{ msg }}
  </h1>
  <h1>{{ reversedMessage }}</h1>
</template>

<script>
export default {
  data() {
    return {
      msg: 'Hello?'
    }
  },
  computed: {
    reversedMessage() {
      return this.msg.split('').reverse().join('')
    }
  },
  watch: {
    // `changeMessage()` 를 통해 할당 연산자를 변경하고 있음  
    // `msg` 데이터는 `watch`에 의해 감시되고 있다가, 변경사항이 생기면 해당 로직이 동작한다 
    msg() {
      console.log('msg:', this.msg)
    }, // msg: Good!
    reversedMessage() {
      console.log('reversedMessage: ', this.reversedMessage)
    } // reversedMessage:  !dooG
  },  // 기존의 데이터 뿐만 아니라, 계산된 데이터도 감시할 수 있다
  methods: {
    changeMessage() {
      this.msg = 'Good!'
    } 
  }
}
</script>

```vue
<script>
  msg(newValue) {
    console.log('msg:', newValue)
  }, // watch에 들어가는 메소드들의 첫번째 매개변수로는 실제로 변경된 값을 사용할 수 있다
  reversedMessage(newValue) {
    console.log('reversedMessage: ', newValue)
}
</script>
```
