# Document Object Model API(DOM API)

## Element vs Node
```html
<div>
  123
  <span>abc</span>
</div>
```
```js
const divEl = document.querySelector('div')
console.log('Element:', divEl)
// Element: <div>...</div>
```
```js
const div = document.querySelectorAll('div')
console.log('', div)
// NodeList [div]
```

html브라우저는 단순요소가 있고, Node개념이 존재한다  
Element는 `div`이고, Node라는 것은 `div`가 가지는 전체 구조를 Node라고 한다  
내부에 존재하는 `123`, `abc`라는 텍스트와, span요소 까지 합친 것을 Node라고 볼 수 있는 것이다  
Node는 조직, Element는 조직원이다..!

```js
const divEl = document.querySelector('div')
console.log('Element:', divEl.childNotes)
```

## id
```html
<div id="abc xyz">
</div>
```
```js
const divEl = document.querySelector('div')
console.log(divEl.id)
// abc xyz
// id 값을 출력해준다
```

## className
class는 JS에 존재하는 예약어이므로, 사용 불가능

```html
<div id="abc xyz" class="btn btn-xs btn-primary">
</div>
```
```js
const divEl = document.querySelector('div')
console.log(divEl.className)
// btn btn-xs btn-primary
```

## classList
```js
const divEl = document.querySelector('div')
console.log(divEl.classList.contains())
// 클래스 추가(add) / 제거(remove) / 확인(contains)
```
```js
// 클래스 추가(add)

divEl.classList.add('hee')
// 주의할 점은, 앞에서 class임을 명시해줬기 때문에, .hee가 아닌, 추가 할 class의 이름만 적는다
```

## parentNode
부모 요소가 반환된다

## previousElementSibling && nextElementSibling
이전, 다음 형제 요소 찾기

## innerHTML
해당 요소의 내부HTML구조(즉 자신을 제외한 내부!) 출력

## textContent
해당 요소의 내부 텍스트 내용 출력

textContent는 글자 내용만 다루는 것이고, innerHTML은 실제 HTMl구조이다

## prepend, append
내부의 앞쪽, 내부의 뒷쪽  
단 글자로만 들어간다  
한 개 이상을 넣을 수 있다
```js
divEl.append(h2El1, h2El2)
```

## attributes
해당 요소가 가지는 속성의 값을 얻을 수 있다
```js
console.log(divEl.getAttribute('title'))
```
보통 `get`이 있으면, `set`도 있다  
즉 값을 지정하는 것

```js
divEl.setAttribute('title', 'aabbcc')
```
`set`은 어떠한 값으로 변경할 것인지, 값도 같이 지정해줘야한다

## dataset
요소에 문자 데이터를 저장할 때, 사용
```js
const user = {
  name: 'Hee',
  age: 99
}
divEl.dataset.user = JSON.stringify(user)
// data-user

console.log(JSON.parse(divEl.dataset.user))
```

```html
<div data-user-name="Hee">
</div>
```
```js
console.log(divEl.dataset.userName)
// Hee
```

## 요소 크기
```js
console.log(divEl.clientWidth)
console.log(divEl.clientHeight)
```

## 요소 위치
```js
console.log(divEl.clientTop)
console.log(divEl.clientLeft)
```

## 요소 렌더링 정보
```js
console.log(divEl.getBoundingClientRect())
console.log(divEl.getBoundingClientRect().top)
console.log(divEl.getBoundingClientRect().left)
```
단점이라고 하면, getter가 아닌, 함수 호출이다  
함수가 호출 된 다음에 요소의 렌더링 정보를 잰다  
즉, 최신정보를 얻어낸다는 장점은 있지만, 그 때 그 때 화면을 계산하게 된다

## createElement
```js
const h1El = document.createElement('h1')
// 메모리상에 가상으로 요소를 만든다

h1El.id = 'abc'
h1El.setAttribute('id', 'abc')
// 둘은 같은 결과를 가지는 방법이다

h1El.classList.add('btn')

document.body.append(h1El)
// 메모리상 그 요소를 내부의 뒤쪽에 밀어넣는다
```

## event

### addEventListener
```js
const divEl = document.querySelector('div')

// Event handler == Callback
divEl.addEventListener('click', e => {
  console.log(e)
})
```
```js
const inputEl = document.querySelector('input')
inputEl.addEventListener('input', e => {
  console.log(e)
})

inputEl.addEventListener('keydown', e => {
  console.log(e)
})
// 한글 입력시 두 번 입력되는 이슈가 있다

inputEl.addEventListener('keydown', e => {
  if (e.isComposing) return
  console.log(e.target.value)
})
// 위에 나온 한글 이슈를 해결 할 수 있다
```